/*
auto-generated by: https://github.com/react-spring/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useMemo, useState } from 'react'
import { useLoader, useFrame, useThree } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import {useHover} from '../Outline'

export default function Model(props) {
  const group = useRef()
  const { nodes, materials } = useLoader(GLTFLoader, '/assests/chair_type_1.glb')
  const texture = useMemo(() => new THREE.TextureLoader().load(props.url), [props.url])

  //for rotaion
  const {ref, ...rest} = props.hover();
  const [isClicked, setIsClicked]= useState(false);
  const {camera} = useThree();

  function clickHandler() {
    // console.log(e, ref);
    if (ref.current) {
      if(!isClicked)
      setIsClicked(true);
    else setIsClicked(false);
      // const objectPosition = ref.current.position;
      const objectPosition = ref.current.position;
      const cameraPosition = camera.position;

     // var offset = new THREE.Vector3(objectPosition.x, objectPosition.y + 1, objectPosition.z);

      //cameraPosition.lerp(offset, 0.006);
       cameraPosition.x = objectPosition.x;
       cameraPosition.y = objectPosition.y+1.5;
       cameraPosition.z = objectPosition.z+2;

      // console.log({cameraPosition});
      camera.lookAt(objectPosition);
    }
  }
  useFrame(() => {
    //camera.updateProjectionMatrix()
    const objectPosition = ref.current.position;
      if (isClicked) {
      
      const rotSpeed = 0.005;
      // if (camera.position.y < objectPosition.y + 3) {
        camera.position.x = camera.position.x * Math.cos(rotSpeed) + camera.position.z * Math.sin(rotSpeed);
    camera.position.z = camera.position.z * Math.cos(rotSpeed) - camera.position.x * Math.sin(rotSpeed)+0.0005;
      // }
      camera.lookAt(objectPosition);
    }
    else{
      camera.lookAt(objectPosition);
    }
  });

  return (
    // <group ref={group} {...props} dispose={null}>
    //   <mesh material={materials.Chair_mtl} geometry={nodes.chair.geometry} position={props.position} rotation={props.rotation} />
    // </group>
    <group  ref={ref}  {...rest} {...props} dispose={null}>
      <mesh geometry={nodes.chair.geometry} position={props.position} rotation={props.rotation}  onClick={clickHandler} >
      <meshStandardMaterial attach="material">
        <primitive attach="map" object={texture} />
      </meshStandardMaterial>
      </mesh>
    </group>
  )
}
